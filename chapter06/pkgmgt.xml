<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-pkgmgt">
  <?dbhtml filename="pkgmgt.html"?>

  <title>Управление пакетами</title>

  <para>Часто задаваемый вопрос по книге LFS - управление пакетами. Менеджер пакетов позволяет отслеживать установку файлов, делая процесс удаления и обновления пакетов существенно проще. Кроме файлов и библиотек, пакетный менеджер будет управлять установкой файлов конфигурации. Не удивляйтесь, в этом разделе не будет информации и рекомендаций по поводу пакетного менеджера. В этом разделе, будет представлена информация о наиболее популярных механизмах работы пакетного менеджера. Идеальным пакетным менеджером для вас может стать такая программа, которая способна комбинировать несколько техник. В этом разделе также кратко упоминается о тех проблемах, которые могут возникнуть при обновлении пакетов:</para>

  <itemizedlist>
    <listitem>
      <para>Работа с системами управления пакетов отвлекает внимание от целей этой книги - обучение тому, как построена Linux система.</para>
    </listitem>

    <listitem>
      <para>Существует множество решения, для управления пакетами. Каждый из них имеет свои достоинства и недостатки. Угодить всем - трудно.</para>
    </listitem>
  </itemizedlist>

  <para>Есть несколько советов, которые содержатся в проекте <ulink url="&hints-index;">Советы</ulink>.  Ознакомьтесь с ними, возможно вы найдете решение, которое соответствует вашим потребностям.</para>

  <sect2>
    <title>Проблемы с обновлением</title>

    <para>пакетный менеджер действительно упрощает обновление пакетов до новых версий, когда они публикуются. Как правило, инструкции в книгах LFS и BLFS могут быть использованы для обновления до новых версий. Вот некоторые моменты, которые необходимо учесть при обновлении пакетов до новых версий, особенно если обновление происходит на запущенной системе.</para>

    <itemizedlist>
      <listitem>
        <para>Если необходимо обновить пакет Glibc до новой версии (например с 2.19 до 2.20) безопаснее всего выполнить сборку всей системы LFS заново. Также, можно выполнить пересборку всех пакетов в порядке их зависимостей. Не такой подход не рекомендуется.</para>
      </listitem>

      <listitem>
        <para>Если пакет содержащий разделяемую (shared) библиотеку обновлён, и наименование библиотеки изменилось, тогда все пакеты, которые динамически слинкованы к библиотеке нужно заново компилировать, с указанием на новую версию библиотеки.(Обратите внимание, что нет никакой корреляции между версией пакета и имени библиотеки.). Например, рассмотрим пакет foo-1.2.3 который установил разделяемую библиотеку с наименованием <filename class='libraryfile'>libfoo.so.1</filename>. Допустим, вы обновили пакет до новой версии - foo-1.2.4, который установил новую версию разделяемой библиотеки <filename class='libraryfile'>libfoo.so.2</filename>. В данном случае,  все пакеты, динамически слинкованные на библиотеку  <filename class='libraryfile'>libfoo.so.1</filename> должны  быть заново скомпилированы с указанием на новую версию библиотеки <filename class='libraryfile'>libfoo.so.2</filename>. Обратите внимание, что не следует удалять предыдущие версии библиотек до тех пор, пока все пакеты, которые на нёё ссылаются не перекомпилированы.</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2>
    <title>Методы управления пакетами</title>

    <para>Ниже приведены некоторые общие методы управления пакетами. До принятия решения о менеджере пакетов, проведите  некоторое исследование различных методов, особенно обратите внимание на их недостатки.</para>

    <sect3>
      <title>Все у меня в голове!</title>

      <para>Да, это метод управления пакетами. Некоторым пользователям не нужен пакетный менеджер, потому что они прекрасно знают все установленные пакеты, и какие файлы им принадлежат. Некоторым пользователям также не требуется пакетный менеджер, потому что они пересобирают всю систему когда пакет поменяется.</para>

    </sect3>

    <sect3>
      <title>Установка в отдельные каталоги</title>

      <para>Это упрощенная техника, для которой не требуются дополнительные программы или пакеты, для управления установкой. Каждый пакет устанавливается в отдельный каталог. Например пакет foo-1.1 будет установлен в каталог <filename class='directory'>/usr/pkg/foo-1.1</filename> и символическая ссылка будет создана с <filename class='directory'>/usr/pkg/foo</filename> на каталог <filename class='directory'>/usr/pkg/foo-1.1</filename>. При установке новой версии пакета foo-1.2, он будет установлен в каталог <filename class='directory'>/usr/pkg/foo-1.2</filename> а предыдущая символическая ссылка будет заменена символической ссылкой на каталог с новой версией пакета.</para>

      <para>Переменные окружения, такие как <envar>PATH</envar>,<envar>LD_LIBRARY_PATH</envar>,<envar>MANPATH</envar>,<envar>INFOPATH</envar> и <envar>CPPFLAGS</envar> необходимо расширить, включив каталог <filename>/usr/pkg/foo</filename>. Для большого количества пакетов, такая техника становится неуправляемой.</para>

    </sect3>

    <sect3>
      <title>Управление пакетами с использованием символических ссылок</title>

      <para>Это вариация предыдущей техники.Каждый пакет устанавливается аналогично, но вместо создания символической ссылки, каждому файлу создаётся символическая ссылка в иерархию каталогов <filename class='directory'>/usr</filename>. Это исключает необходимость модификации значений переменных окружения. Такие ссылки могут быть созданы пользователям вручную, для автоматизации создания пакетов, однако, многие менеджеры пакетов были созданы с использованием именной такого метода. Наиболее популярные из них - Stow,
      Epkg, Graft, and Depot.</para>

      <para>Установка должна быть подделана, чтобы пакет считал что его установка производится в каталог <filename class="directory">/usr</filename>, однако, на самом деле, он будет установлен в иерархие каталогов <filename class="directory">/usr/pkg</filename>. Установка пакетов таким способом может быть нетривиальной задачей. Например, будет произведена установка пакета libfoo-1.1. Следующие инструкции не позволят установить пакет должным образом:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr/pkg/libfoo/1.1
make
make install</userinput></screen>

      <para>Установленный таким образом пакет будет работать, но те пакеты, которые имеют от него зависимости, могут не иметь ссылки на libfoo как и следовало ожидать.Если компилируется пакет, который ссылается на
       libfoo, можно заметить, что он связан с <filename class='libraryfile'>/usr/pkg/libfoo/1.1/lib/libfoo.so.1</filename> вместо <filename class='libraryfile'>/usr/lib/libfoo.so.1</filename> как и следовало ожидать. Правильный подход заключается в использовании переменной окружения  <envar>DESTDIR</envar> чтобы подделать установку пакета. Такой метод работает следующим образом:</para>

<screen role="nodump"><userinput>./configure --prefix=/usr
make
make DESTDIR=/usr/pkg/libfoo/1.1 install</userinput></screen>

      <para>Большинство пакетов поддерживают такой способ, но некоторые нет. Для несовместимых пакетов, вам понадобится вручную выполнить установку пакета, или еще проще устанавливать такие пакеты в каталог <filename class='directory'>/opt</filename>.</para>

    </sect3>

    <sect3>
      <title>На основе временной метки</title>

      <para>Файлу присваивается метка времени, перед установкой пакета. После установки, выполняется команда <command>find</command> с соответствующими параметрами, результат выполнения которой будет представлять из себя журнал со всеми файлами установленных после указанной метки времени. Пакетный менеджер, использующий такой подход имеет журнал установки.</para>

      <para>Этот метод имеет преимущество - простота, но имеет и несколько недостатков. В процессе установки, файлы, которые были установленны с другими метками времени, которые отличаются от текущего времени, не будут отслеживаться пакетным менеджером. Также, возможно устанавливать один пакет за раз. Журналы ненадежны, если два пакета установлены их двух разных терминалов.</para>

    </sect3>

    <sect3>
      <title>Отслеживание сценариев установки</title>

      <para>In this approach, the commands that the installation scripts perform
      are recorded.  There are two techniques that one can use:</para>

      <para>The <envar>LD_PRELOAD</envar> environment variable can be set to
      point to a library to be preloaded before installation.  During
      installation, this library tracks the packages that are being installed by
      attaching itself to various executables such as <command>cp</command>,
      <command>install</command>, <command>mv</command> and tracking the system
      calls that modify the filesystem. For this approach to work, all the
      executables need to be dynamically linked without the suid or sgid bit.
      Preloading the library may cause some unwanted side-effects during
      installation. Therefore, it is advised that one performs some tests to
      ensure that the package manager does not break anything and logs all the
      appropriate files.</para>

      <para>The second technique is to use <command>strace</command>, which
      logs all system calls made during the execution of the installation
      scripts.</para>
    </sect3>

    <sect3>
      <title>Creating Package Archives</title>

      <para>In this scheme, the package installation is faked into a separate
      tree as described in the Symlink style package management. After the
      installation, a package archive is created using the installed files.
      This archive is then used to install the package either on the local
      machine or can even be used to install the package on other machines.</para>

      <para>This approach is used by most of the package managers found in the
      commercial distributions. Examples of package managers that follow this
      approach are RPM (which, incidentally, is required by the <ulink
      url="http://refspecs.linuxfoundation.org/lsb.shtml">Linux
      Standard Base Specification</ulink>), pkg-utils, Debian's apt, and
      Gentoo's Portage system.  A hint describing how to adopt this style of
      package management for LFS systems is located at <ulink
      url="&hints-root;fakeroot.txt"/>.</para>

      <para>Creation of package files that include dependency information is
      complex and is beyond the scope of LFS.</para>

      <para>Slackware uses a <command>tar</command> based system for package
      archives.  This system purposely does not handle package dependencies
      as more complex package managers do.  For details of Slackware package
      management, see <ulink
      url="http://www.slackbook.org/html/package-management.html"/>.</para>
    </sect3>

    <sect3>
      <title>User Based Management</title>

      <para>This scheme, unique to LFS, was devised by Matthias Benkmann, and is
      available from the <ulink url="&hints-index;">Hints Project</ulink>. In
      this scheme, each package is installed as a separate user into the
      standard locations. Files belonging to a package are easily identified by
      checking the user ID. The features and shortcomings of this approach are
      too complex to describe in this section. For the details please see the
      hint at <ulink url="&hints-root;more_control_and_pkg_man.txt"/>.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Deploying LFS on Multiple Systems</title>

    <para>One of the advantages of an LFS system is that there are no files that
    depend on the position of files on a disk system.  Cloning an LFS build to
    another computer with the same architecture as the base system is as
    simple as using <command>tar</command> on the LFS partition that contains
    the root directory (about 250MB uncompressed for a base LFS build), copying
    that file via network transfer or CD-ROM to the new system and expanding
    it.  From that point, a few configuration files will have to be changed.
    Configuration files that may need to be updated include:
    <filename>/etc/hosts</filename>,
    <filename>/etc/fstab</filename>,
    <filename>/etc/passwd</filename>,
    <filename>/etc/group</filename>,
    <phrase revision="systemd">
      <filename>/etc/shadow</filename>, and
      <filename>/etc/ld.so.conf</filename>.
    </phrase>
    <phrase revision="sysv">
      <filename>/etc/shadow</filename>,
      <filename>/etc/ld.so.conf</filename>,
      <filename>/etc/sysconfig/rc.site</filename>,
      <filename>/etc/sysconfig/network</filename>, and
      <filename>/etc/sysconfig/ifconfig.eth0</filename>.
    </phrase>
    </para>

    <para>A custom kernel may need to be built for the new system depending on
    differences in system hardware and the original kernel
    configuration.</para>

    <note><para>There have been some reports of issues when copying between
    similar but not identical architectures. For instance, the instruction set
    for an Intel system is not identical with an AMD processor and later
    versions of some processors may have instructions that are unavailable in
    earlier versions.</para></note>

    <para>Finally the new system has to be made bootable via <xref
    linkend="ch-bootable-grub"/>.</para>

  </sect2>

</sect1>
