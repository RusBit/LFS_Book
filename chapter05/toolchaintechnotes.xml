<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>Технические примечания относительно временного набора инструментов</title>

  <para>В этом разделе объясняются детали по всему процессу сборки. Не обязательно сразу понимать все что здесь написано. Большая часть информации станет понятной в процессе сборки. К этому разделу можно обратиться в любое время.</para>

  <para>Главной задачей главы <xref linkend="chapter-temporary-tools"/> является создание временной области которая содержит требуемый набор инструментов, который может быть изолирован от хост-системы. Использование команды <command>chroot</command> в оставшихся главах обеспечит чистое окружение и беспроблемную сборку конечной системы LFS. Такой процесс был выбран чтобы минимизировать риски для новых читателей и одновременно как образовательная цель.</para>

  <note>
    <para>Перед тем как приступить, необходимо знать название платформы хост-системы, часто называемой целевой "триплет". Простой способ это определить - выполнить команду <command>config.guess</command> которая поставляется с исходными кодами многих пакетов. Распакуйте пакет Binutils и выполните команду <userinput>./config.guess</userinput> и запишите вывод. Например, для 32 битного процессора intel вывод будет <emphasis>i686-pc-linux-gnu</emphasis>. Для 64 битного - <emphasis>x86_64-pc-linux-gnu</emphasis>.</para>

    <para>Также, необходим знать название динамического линковщика, часто называемого динамический загрузчик (не путать со стандартным линковщиком <command>ld</command>, поставляемый в пакете Binutils). Динамический линковщик поставляется в пакете Glibc. Он находит и загружает общие библиотеки необходимые для выполнения и запуска программ, после чего запускает программу. Название динамического линковщика на 32-битной машине с процессором intel будет <filename
    class="libraryfile">ld-linux.so.2</filename> (<filename
    class="libraryfile">ld-linux-x86-64.so.2</filename> для 64-битных систем). Надежный способ узнать название динамического линковщика на хост-системе - проверить произвольный бинарный файл хост-системы выполнив команду <userinput>readelf -l
    &lt;название бинарного файла&gt; | grep interpreter</userinput> и проверить вывод. Официальная ссылка, охватывающая все платформы, находится в файле <filename>shlib-versions</filename> в корне каталога с исходными кодом пакета Glibc.</para>
  </note>

  <para>Ключевые технические указания как в <xref
  linkend="chapter-temporary-tools"/> работает метод сборки:</para>

  <itemizedlist>
    <listitem>
      <para>Выполнив настройку названия платформы хост-системы, изменив поле &quot;vendor&quot;
      целевого триплета с помощью переменной окружения <envar>LFS_TGT</envar>, чтобы выполнить первую сборку пакетов Binutils и GCC с совместимым кросс-линковщиком и кросс-компилятором. Вместо того, чтобы создать файлы для другой архитектуры, кросс-линковщик и кросс-компилятор создадут файлы совместимые с текущим аппаратным обеспечением.</para>
    </listitem>
    <listitem>
      <para>Временные библиотеки будут скомпилированы кросс-компилятором, потому что он не зависит от хост-системы . Такой метод исключает потенциальное загрязнение целевой системы, уменьшая вероятность того, что будут включены какие либо заголовочные файлы и библиотеки хост-системы в временный набор инструментов.  Кросс компиляция также позволяет выполнять сборку как 32-битных, так и 64-битных библиотек на 64-битном совместимом аппаратном обеспечении.</para>
    </listitem>
    <listitem>
    <para>Аккуратная манипуляция с исходными кодами пакета GCC будет указывать компилятору какой целевой динамический загрузчик необходимо использовать.</para>
    </listitem>
  </itemizedlist>

  <para>Пакет Binutils устанавливается первым, потому что команда <command>configure</command> запускает GCC и Glibc и выполняет различные функциональные тесты ассемблера и линковщика для определения какие функции программного обеспечения включить или выключить. Некорректно настроеный GCC или Glibc могут привести к неработоспособности всего временного набора инструментов, и такая проблема может проявиться только в конце сборки дистрибутива. Сбои при выполнении тестов могут сигнализировать о наличии таких обшибок.</para>

  <para>Binutils installs its assembler and linker in two locations,
  <filename class="directory">/tools/bin</filename> and <filename
  class="directory">/tools/$LFS_TGT/bin</filename>. The tools in one
  location are hard linked to the other. An important facet of the linker is
  its library search order. Detailed information can be obtained from
  <command>ld</command> by passing it the <parameter>--verbose</parameter>
  flag. For example, an <userinput>ld --verbose | grep SEARCH</userinput>
  will illustrate the current search paths and their order. It shows which
  files are linked by <command>ld</command> by compiling a dummy program and
  passing the <parameter>--verbose</parameter> switch to the linker. For example,
  <userinput>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</userinput>
  will show all the files successfully opened during the linking.</para>

  <para>The next package installed is GCC. An example of what can be
  seen during its run of <command>configure</command> is:</para>

<screen><computeroutput>checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

  <para>This is important for the reasons mentioned above. It also demonstrates
  that GCC's configure script does not search the PATH directories to find which
  tools to use. However, during the actual operation of <command>gcc</command>
  itself, the same search paths are not necessarily used. To find out which
  standard linker <command>gcc</command> will use, run:
  <userinput>gcc -print-prog-name=ld</userinput>.</para>

  <para>Detailed information can be obtained from <command>gcc</command> by
  passing it the <parameter>-v</parameter> command line option while compiling
  a dummy program. For example, <userinput>gcc -v dummy.c</userinput> will show
  detailed information about the preprocessor, compilation, and assembly stages,
  including <command>gcc</command>'s included search paths and their order.</para>

  <para>Next installed are sanitized Linux API headers. These allow the standard
  C library (Glibc) to interface with features that the Linux kernel will
  provide.</para>

  <para>The next package installed is Glibc. The most important considerations
  for building Glibc are the compiler, binary tools, and kernel headers. The
  compiler is generally not an issue since Glibc will always use the compiler
  relating to the <parameter>--host</parameter> parameter passed to its
  configure script; e.g. in our case, the compiler will be
  <command>i686-lfs-linux-gnu-gcc</command>. The binary tools and kernel
  headers can be a bit more complicated. Therefore, take no risks and use the
  available configure switches to enforce the correct selections. After the run
  of <command>configure</command>, check the contents of the
  <filename>config.make</filename> file in the <filename
  class="directory">glibc-build</filename> directory for all important details.
  Note the use of <parameter>CC="i686-lfs-gnu-gcc"</parameter> to control which
  binary tools are used and the use of the <parameter>-nostdinc</parameter> and
  <parameter>-isystem</parameter> flags to control the compiler's include
  search path. These items highlight an important aspect of the Glibc
  package&mdash;it is very self-sufficient in terms of its build machinery and
  generally does not rely on toolchain defaults.</para>

  <para>During the second pass of Binutils, we are able to utilize the
  <parameter>--with-lib-path</parameter> configure switch to control
  <command>ld</command>'s library search path.</para>

  <para>For the second pass of GCC, its sources also need to be modified to
  tell GCC to use the new dynamic linker. Failure to do so will result in the
  GCC programs themselves having the name of the dynamic linker from the host
  system's <filename class="directory">/lib</filename> directory embedded into
  them, which would defeat the goal of getting away from the host. From this
  point onwards, the core toolchain is self-contained and self-hosted. The
  remainder of the <xref linkend="chapter-temporary-tools"/> packages all build
  against the new Glibc in <filename
  class="directory">/tools</filename>.</para>

  <para>Upon entering the chroot environment in <xref
  linkend="chapter-building-system"/>, the first major package to be
  installed is Glibc, due to its self-sufficient nature mentioned above.
  Once this Glibc is installed into <filename
  class="directory">/usr</filename>, we will perform a quick changeover of the
  toolchain defaults, and then proceed in building the rest of the target
  LFS system.</para>

</sect1>
